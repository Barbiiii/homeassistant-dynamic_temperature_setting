blueprint:
  name: Klimaanlage - Dynamische Temperaturanpassung (Faktor)
  description: Passt die Soll-Temperatur einer Klimaanlage/Heizung dynamisch basierend auf einem externen Temperatursensor an. Nutzt einen einstellbaren Korrekturfaktor.
  domain: automation
  input:
    climate_entity:
      name: Klimaanlage/Heizung
      description: Die Entität (z.B. climate.schlafi_c931), deren Temperatur geregelt wird.
      selector:
        entity:
          domain: climate
    temp_sensor_entity:
      name: Temperatursensor (Ist-Temperatur)
      description: Der externe Temperatursensor (z.B. sensor.lumi_temperatur).
      selector:
        entity:
          domain: sensor
    wunsch_temp_entity:
      name: Wunschtemperatur (Input-Helper)
      description: Der input_number-Helfer, der die gewünschte Temperatur speichert.
      selector:
        entity:
          domain: input_number
    korrektur_faktor:
      name: Korrekturfaktor (z.B. 3.0)
      description: Additive Korrektur zur Temperaturdifferenz (Diff + Faktor). Höherer Wert = aggressiveres Heizen.
      default: 3.0
      selector:
        number:
          min: 0.5
          max: 10.0
          unit_of_measurement: "°C"
          mode: box
    window_sensor_entity:
      name: Fenster-/Türsensor (Lüftungsprüfung)
      description: Optionaler Sensor, der prüft, ob gelüftet wird. Automatisierung stoppt, wenn Sensor offen ist (state 'on'). Leer lassen, um die Prüfung zu ignorieren.
      selector:
        entity:
          domain: binary_sensor
      default: ''

trigger:
  - platform: state
    entity_id: !input temp_sensor_entity
  - platform: state
    entity_id: !input wunsch_temp_entity

action:
  # OPTIONALE PRÜFUNG: Fenster/Tür offen
  - if: '{{ iif(is_state(''!input window_sensor_entity'', ''on''), true, false) }}'
    then:
      - stop: "Fenster/Tür ist offen, Automatisierung wird gestoppt."
    # Das `if`-Statement wird nur ausgeführt, wenn `!input window_sensor_entity` nicht leer ist.
    # Wenn der Sensor leer ist, wertet `is_state` als `unknown` und die `if`-Bedingung wird ignoriert.
    # HINWEIS: Dies ist eine **optionale** Verbesserung, da Ihre ursprüngliche Logik dafür fehlte.
    # Wollen Sie die Prüfung wirklich nur, wenn ein Sensor definiert ist, ist eine zusätzliche `condition` mit `!input window_sensor_entity != ''` nötig.

  - variables:
      # Zuweisung der Entitäts-IDs
      climate_ent: !input climate_entity
      temp_sensor_ent: !input temp_sensor_entity
      wunsch_temp_ent: !input wunsch_temp_entity
      
      # Wert des Korrekturfaktors als einfache Variable zuweisen
      faktor_value: !input korrektur_faktor 
      
      # Abrufen der Ist- und Wunschtemperatur
      wunsch_temp: "{{ states(wunsch_temp_ent) | float(0) }}"
      ist_temp: "{{ states(temp_sensor_ent) | float(0) }}"
      
      max_solltemp: 30.0 # Bessere Konsistenz, wenn mit float-Werten gearbeitet wird
      
      # Die Differenz wird hier nicht explizit berechnet, da sie in der Jinja2-Logik
      # mit den gefloateten Werten genutzt wird, was sicherer ist.
      
      # LOGIK: Hybrid-Steuerung (Additive Faktoren für Heizen, Multiplikativ/Limit für Abkühlen)
      # Die gesamte Logik wird in einer einzigen Template-Variable zusammengefasst
      delta_fuer_heizen: >
        {% set faktor = faktor_value | float(3.0) %}
        {% set wunsch = wunsch_temp | float(0) %}
        {% set ist = ist_temp | float(0) %}
        {% set temp_diff = wunsch - ist %}
        
        {# ZIEL: Ist-Temperatur auf Wunsch-Temperatur bringen #}
        {% if ist < (wunsch - 0.25) %}
            {# IST < WUNSCH - 0.25: Klares Heizen erforderlich #}
            {% set raw_additive_delta = temp_diff + faktor %}
            {{ raw_additive_delta | round(1) }}
        
        {% elif ist < (wunsch + 0.25) %}
            {# WUNSCH - 0.25 <= IST < WUNSCH + 0.25: Halten/Feinheizen #}
            {% set raw_additive_delta = temp_diff + faktor %}
            {# Fall: Aggressiver Boost im Nahbereich (z.B. wenn noch leicht geheizt werden muss) #}
            {% if ist < wunsch %}
                {{ (raw_additive_delta + 0.5) | round(1) }}
            {% else %}
                {# IST >= WUNSCH - Halten/Minimale Reduktion (kann auch 0.0 oder kleiner sein, wenn Faktor > Diff) #}
                {{ raw_additive_delta | round(1) }}
            {% endif %}

        {# IST >= WUNSCH + 0.25: Abkühlen/Lüften Zone #}
        {% else %}
            {# Wenn Lüftermodus nicht aktiviert wird, hier die Reduktions-Logik einfügen, z.B. -1.0 #}
            -1.0
        {% endif %}
          
      # Berechnet die neue Solltemperatur und rundet sie auf die nächste 0.5er Stufe
      neue_solltemp: >
        {% set ungefilterte_solltemp = wunsch_temp | float(0) + delta_fuer_heizen | float(0) %}
        {% set temp_mal_zwei = ungefilterte_solltemp * 2 %}
        {% set aufgerundet = temp_mal_zwei | round(0, 'ceil') %}
        {% set gerundet_final = aufgerundet / 2 %}
        {{ [max_solltemp, gerundet_final] | min | round(1) }}
        
      aktuelle_solltemp: "{{ state_attr(climate_ent, 'temperature') | float(0) }}"
      # Wir nutzen 'neue_solltemp' als die Solltemperatur, die auch die 0.5er Rundung enthält

  - choose:
      # ZONE 1: LÜFTERMODUS (Ist >= Wunsch + 0.25)
      - conditions:
          - condition: template
            # WICHTIG: Die Variablen werden im 'variables'-Block initialisiert und sind hier verfügbar
            value_template: "{{ ist_temp | float(0) > (wunsch_temp | float(0) + 0.25) }}"
        sequence:
          - service: climate.set_hvac_mode
            target:
              entity_id: '{{ climate_ent }}'
            data:
              hvac_mode: fan_only
          - service: climate.set_fan_mode
            target:
              entity_id: '{{ climate_ent }}'
            data:
              fan_mode: low # Home Assistant empfiehlt Kleinbuchstaben

    default:
      # ZONE 3 & 4: Alle HEIZ-Fälle (oder Halten/Abkühlen) greifen hier
      - service: climate.set_hvac_mode
        target:
          entity_id: '{{ climate_ent }}'
        data:
          hvac_mode: heat # Sollte auf 'heat_cool' oder 'auto' stehen, wenn die Anlage kühlen kann
      - service: climate.set_temperature
        target:
          entity_id: '{{ climate_ent }}'
        data:
          # Hier verwenden wir die vorberechnete und gerundete neue Solltemperatur
          temperature: "{{ neue_solltemp }}" 
          hvac_mode: heat
      - service: climate.set_fan_mode
        target:
          entity_id: '{{ climate_ent }}'
        data:
          fan_mode: mid # Home Assistant empfiehlt Kleinbuchstaben
